## Гиренко Дмитрий Владимирович
## Компьютерная графика

## Тема: Введение в компьютерную графику ч.1

#### 1. Области применения КГ.

**КГ** - область информатики, в сферу интересов которой входят все аспекты формирования изображения.

**Области применения:**
1. моделирование
2. проектирование
3. GUI
4. представление

```
CLI - comand line interface <-> GUI
```
#### 2. Изображение и его виды.
**Виды изображений:**
* реалистичное или физическое (глаз, фотоаппарат)
* синтезируемое - продукт КГ

**Особенности формирования:**
1. физическое: объект, субъект и соответствие
2. синтезируемое:
    1. объект - то, что моделируем, сцена
    2. виртуальная камера (некий посредник)
    3. источники света добавляются в сцену (отдельный программный объект)

#### 3. Графическая система.

**Система КГ** - вычислительная система общего назначения (с расширенной функциональностью отдельных компонент).

![](https://github.com/ShAlinaShulgina/ComputerGraphics/blob/master/pic/%D0%9A%D0%93.png?raw=true)

**Буфер кадра и пиксели:**
Все современные графические системы использую растровый способ создания изображения:
  * изображение - массив точек (изображение дискретно);
  точки называются пикселями (px);
  растр - это массив точек;
  * каждый пиксель имеет четко определенное положение на экране (пиксели локализованы)
  * массив кодов зацветки пикселей хранится в буфере кадров (frame buffer)
  * под код буфера кажда может выделяться отдельная память (VRAM || DRAM)

**Характеристики буфера кадра:**
1. глубина (depth) - количество бит, выделенных отдельному коду зацветки пикселя (как много информации о цвете пиксель может хранить)

1 бит      | 2 цвета
-----------| -----------
8 бит      | 2^8 цветов
16 бит     |  2^16 цветов
 \> 24 бит  |  true-color

2. разрешающая способность (разрешение)

В простых графических системах используется один процессор, на который возлагаются все **задачи КГ:**
1. формирование примитивов (точки, линии, треугольники, ...)
2. проецирование (изначально x,y,z -> проецируется на плоский экран x,y)
3. растровое преобразование (перевод в коде зацветки пикселя)

Для ускорения процесса подзадачи 1-3 могут выносится в отдельный процессор.

## Тема: Введение в компьютерную графику ч. 2

#### 1. Интерфейс прикладного программиста.

![](https://github.com/ShAlinaShulgina/ComputerGraphics/blob/master/pic/API.png?raw=true)

**Интерфейс прикладного программиста (API)** - множество функций, которые образуют графическую библиотеку; спецификация этих функций - API (интерфейс между прикладной программой и графической системой).
Графичекий API - наш интерес.

**API должен обеспечивать работу с:**
- объектами
- наблюдателями (виртуальная камера)
- источники света
- материал объекта

**Характеристики графического API:**
1. Объекты описываются массивами вершин. Вершина - абстрактное вспомогальное понятие. Существует набор примитивов:
    - точки
    - отрезки
    - треугольники
    - многоугольники
    - сферы
    - и т.д.
2. Повороты, перемещение, масштабирование.
3. Источники света. Доступны разные типы - точечный, прожектор и фоновый. Существует возможность регулирования оптических свойств, яркости, интенсивности.
4. Существует возможность задания глянцевой или матовой поверхности, цвета и степени неровности.

**Парадигра "моделирования - тонирования".** Существует две концепции формирования изображения:
1. Модель минтезируемой камеры.
Сразу формируется готовое изображение, смоделированное и в цвете.

2. Моделирование-тонирование.
Сначала моделируется  бесцветная сцена, а затем тонируется *(rendering)* (связка через промежуточные файлы)

#### 2. Архитектура графической системы.

0. Архитектура Фон-Неймана. Процессор - многофункционален.

1. Дисплейный процессор - отдельный процессор в составе дисплея. Задачи:

    - регенирация изображения;

    - формирование примитивов;

2. Конвейерная архитектура (СБПС - плата). В данной архитектуре формирование изображения разбивается на четыре этапа:

    1. геометрические преобразования - формирование *представления объектов* сцены в разных системах координа; используется аппарат линейной алгебры (матричной математики)

    2. отсечение (clipping) - процесс происходит с использованием отсекающей прямоугольной рамки на плоскости проекции;
        1. объекты, проекции которых попадают во внутреннюю часть отсекающей рамки - учавствуют в формировании изображения;
        2. объекты, которые пересекают отсекающую рамку - учавствуют частично;
        3. остальные отсекаются

    3. проективные преобразования - переход с объемной сцены в плоскую, виды:
        - перспективная;
        - ортогональная;
        - косоугольная

    4. растровые преобразования - преобразования описания двумерных объектов в коды зацветки пикселей **(px)** в буфере кадра.

**Производительность графического конвейера:**

В рассматриваемой структуре обработки графической информации исользуются операции двух типов. На начальной стадии - операции с координатами вершин - числа с плавающей точкой. Все операции после растрового преобразования требуют выполнения побитовых операций на уровне содержимого буфера кадра.

Произведение графического конвейера = производительность при работе с плавающей точкой + производительность при побитоых операциях

Для оптимизации эти два процесса разносятся по разным платам.

## Тема: Начало OpenGL

#### 1. Прикладной интерфейс OpenGL (OGL)

![](https://github.com/ShAlinaShulgina/ComputerGraphics/blob/master/pic/IOGL.png?raw=true)

Категории функций OGL:
1. функции работы с примитивами (primitive functions)
2. функции работы с атрибутами (attribute functions) (изменить цвет, прозрачность)
3. функции визуализации (view functions) (как будет отображаться сцена)
4. функции геометрических проеобразований (transform functions)
5. функции ввода графической интформации (input functions) (в плане назначения)
6. управляющие функции (control functions)

Интерфейсы OGL:
- функции предворяются префиксом 'gl'
- GL - основная библиотека (база)
- дополнительные библиотеки:
    - GLU - предназначена для работы с формированием сложных объектов
    - GLUT - набор функция для работы с окнами
- для читабельности программы введено использование маркосов с профексом 'GL_' (в .h файлах)

Атрибуты OpenGL:
![](https://github.com/ShAlinaShulgina/ComputerGraphics/blob/master/pic/GL.png?raw=true)

#### 2. OpenGL как конечный автомат

OGL работает по принципу **конечного автомата**. Пользователь переводит его в различные состояния или режимы, в котором он останется до момента следующего изменения. Многие параметры состояния связаны с режимами, которые включаются и выключаются командами:
- glEnable()
- glDisable()
    - Компонент состояния
    - Состояние - набор компонентов состояний
    - Режим

#### 3. Конвейер OpenGL

![](https://github.com/ShAlinaShulgina/ComputerGraphics/blob/master/pic/Conveyor.png?raw=true)

*Список отображения (дисплейный список):*
- два варианта хранения данных - список отображения и непосредственный режим (данные как есть);
- информация обрабатывается точно так же, как в непосредственном режиме;
- актуальны при использовании больших наборов данных.

*Блок оценки (вычислитель):*
- все геометрические примитивы описываются вершинами;
- параметрические кривые/поверхности могут быть описаны контрольными точками и многочленами (базисными функциями);
- генерирует вершины по заданным базисным функциям и контрольными точкам.

*Операции с вершинами:*
- преобразуют вершины в примитивы;
- проецирование сцены;
- преобразование координат текстур;
- вычисление цвета при использовании освещения.

*Компоновка примитивов:*
- отсечение;
- компоновка примитивов.

*Операции с пикселями:*
- растровые обрабатываются параллельно вершинам;
- пиксели из системной памяти распаковываются в некоторое количество компонентов, данные масштабируются, трансформируются, и обрабатываются как пиксельные карты;
- пиксельные карты или накапливаются в памяти текстур, или отправляются на растеризацию;
- если данные забираются из буфера кадра, то выполняется ряд операций по пересылке этих пикселей;
- данные из буфера кадра записываются в системную память.

*Компоновка текстур:*
- если текстур несколько, то они помещаются в текстурные объекты.

*Операции с пикселями, Растеризация:*
- преобразование векторных и растровых данных в фрагменты.

*Операции с фрагментами:*
- текстурирование, тексели;
- каждый тексель накладывается на соответсвующий фрагмент;
- специфические функции (прозрачность, эффекты);
- фрагменты записываются в буфер кадра;
- растровые данные преобразуются в коды засветки пикселей.

## Тема: OpenGL. Основы рисования; примитивы, атрибуты.

#### 1. Пояснение

Что такое примитив?
Нет строгого разграничения.

В OpenGL, примитивы в базовой библиотеке GL:
- точка;
- отрезок;
- треугольники;
- 4-хугольник;
- n-угольник;
- текст.

Более сложные примитивы в библиотеке GLU:
- сфера;
- шар.

#### 2. Рисование примитивов

**Вершины:**

- любой объект задается списком вершин;
- **gl**Vertex - функции работы с вершинами предваряются данной конструкцией (формат команды задания вершины);
- **gl**Vertex... , на **...** стоят:
    - размерность - цифра;
    - тип данных координат:
        - d - целочисленные
        - f -  плавающая точка

Пример:
```
glVertex2d(2, 5); - 2-мерная целочисленная
glVertex3f(2.3, 3.21, 10.0) - 3-мерная плавающая точка

v = ... // вектор
glVertex2dv(v)
```

**Формат задания объектов:**

- операторные скобки необходимы для отрисовки объектов
```
glBegin(...);
    glVertex...;
    glVertex...;
glEnd();
```
- в glBegin(...) передается макрос, определяющий тип примитива
- между двумя операторными скобками располагаются команды задания вершин, также могут быть включены некоторые другие команды OGL (не все). Причем, исключения не всегда генерируются (можете не получить ошибку):
    - функции атрибутирования;
    - ... (см. спецификацию)
    - любые конструкции языка программитрования

**Примитивы:**

*Основное различие примитивов* - наличие внутренней области (три линии и треугольник).

1. Точки (GL_POINTS)
```
glBegin(GL_POINTS);
    glVertex2d(2, 3);
    glVertex2d(4, 5);
glEnd(); // получим просто две точки
```
2. Линии (GL_LINES)
```
glBegin(GL_LINES);
    glVertex2d(2, 3);
    glVertex2d(4, 5);
glEnd(); // получим линию через две точки
// если задать четыре точки то будет две линии
```
3. Ломанная линия (GL_LINE_STRIP)
```
glBegin(GL_LINE_STRIP);
    glVertex2d(2, 3);
    glVertex2d(4, 5);
    glVertex2d(10, 6);
glEnd(); // получим ломанную линию через три точки
```
4. Циклическая линия (GL_LINE_LOOP)
```
glBegin(GL_LINE_STRIP);
    glVertex2d(2, 3);
    glVertex2d(4, 5);
    glVertex2d(10, 6);
glEnd(); // получим замкнутую ломанную линию
```
5.  Многоугольники (полигоны)
Особенности:
    - есть внутренняя область, с которой можно работать;
    - используются для апроксимации криволинейных поверхностей;
    - внутренняя область может:
        - тонироваться;
        - текстурироваться;
        - маска (паттерн, шаблон);
    - для корректного отображения внутренней области он должен обладать свойствами, быть:
        - простым (не очень много вершин);
        - выпуклым;
        - плоским;

Типы многоугольников:

5.1. Треугольники (GL_TRIANGLES)

5.2. Четырехугольники (GL_QUADS)

5.3. Некий многоугольник (GL_POLYGON)

5.4. Полосы (GL_TRIANGLE_STRIP, GL_QUADR_STRIP)

![Полоса треугольников](https://github.com/ShAlinaShulgina/ComputerGraphics/blob/master/pic/GL_TRIANGLE_STRIP.png?raw=true)

5.5. Розетка (GL_TRIANGLE_FAN)


Общее представление:

![](https://github.com/ShAlinaShulgina/ComputerGraphics/blob/master/pic/fig.png?raw=true)

6. Криволинейные поврехности
    - апроксимация полигонами
    Тесселяция - мозайка из полигонов.
    - можно использовать готовые примитивы
    - кастомные функции (пользовательские)
    - задать функцию + опорные точки (вычислитель в конвейере)


7. Атрибуты (маска, толщина линии, цвет и т.д.)
Атрибут - любое свойство, которое определяет способ отображения любого примитива.
    - цвета
    - толщина (px)
    - маска (паттерн)
    - градиент

```
INSTALL
$ sudo apt-get update
$ sudo apt-get install libglu1-mesa-dev freeglut3-dev mesa-common-dev

MAKE
g++ main.cpp -o main -lglut -lGLU -lGL

RUN
./main

```


## Тема: Основы рисования: массивы вершин, группы атрибутов

 #### 1. Массивы вершин

1. Предопределены вершины в контексте OpenGl.
2. Можно хранить 8 типов данных - координаты, цвета, координаты текстуры
3. Упрощение работы с большим количеством вершин

Алгоритм использования:
1. Активация требуемого массива
2. Заполнение данными
3. Рисование на основе данных:
    - индивидуальный доступ к элементам
    - создание списков отдельных переменных
    - последовательная обработка элементов массива

**Шаг 1.** Активация массивов

```
glEnableClientState(GLenum array);
                    // GLenum
                    // GL_VERTEX_ARRAY
                    // GL_COLOR_ARRAY
                    // NORMAL
                    // всего 8 штук
glDisableClientState(GLenum array)
```
[glEnableClientState](https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glEnableClientState.xml)
```
Both glEnableClientState and glDisableClientState take a single argument, cap, which can assume one of the following values:

GL_COLOR_ARRAY
    If enabled, the color array is enabled for writing and used during
    rendering when glArrayElement, glDrawArrays, glDrawElements,
    glDrawRangeElements glMultiDrawArrays, or
    glMultiDrawElements is called. See glColorPointer.
GL_EDGE_FLAG_ARRAY
    If enabled, the edge flag array is enabled for writing and used during
    rendering when glArrayElement, glDrawArrays, glDrawElements,
    glDrawRangeElements glMultiDrawArrays, or
    glMultiDrawElements is called. See glEdgeFlagPointer.
GL_FOG_COORD_ARRAY
    If enabled, the fog coordinate array is enabled for writing and used during
    rendering when glArrayElement, glDrawArrays, glDrawElements,
    glDrawRangeElements glMultiDrawArrays, or
    glMultiDrawElements is called. See glFogCoordPointer.
GL_INDEX_ARRAY
    If enabled, the index array is enabled for writing and used during
    rendering when glArrayElement, glDrawArrays, glDrawElements,
    glDrawRangeElements glMultiDrawArrays, or
    glMultiDrawElements is called. See glIndexPointer.
GL_NORMAL_ARRAY
    If enabled, the normal array is enabled for writing and used during
    rendering when glArrayElement, glDrawArrays, glDrawElements,
    glDrawRangeElements glMultiDrawArrays, or
    glMultiDrawElements is called. See glNormalPointer.
GL_SECONDARY_COLOR_ARRAY
    If enabled, the secondary color array is enabled for writing and used
    during rendering when glArrayElement, glDrawArrays,
    glDrawElements, glDrawRangeElements glMultiDrawArrays, or
    glMultiDrawElements is called. See glColorPointer.
GL_TEXTURE_COORD_ARRAY
    If enabled, the texture coordinate array is enabled for writing and used
    during rendering when glArrayElement, glDrawArrays,
    glDrawElements, glDrawRangeElements glMultiDrawArrays, or
    glMultiDrawElements is called. See glTexCoordPointer.
GL_VERTEX_ARRAY
    If enabled, the vertex array is enabled for writing and used during
    rendering when glArrayElement, glDrawArrays, glDrawElements,
    glDrawRangeElements glMultiDrawArrays, or
    glMultiDrawElements is called.  See glVertexPointer.
```

**Шаг 2.** Помещение данных

```
// помещает данные в GL_VERTEX_ARRAY
void glVertexPointer(GLint size, GLenum type,
                     GLsize stride, const GLvoid *p);

glColorPointer(GLint size, GLenum type,
               GLsize stride, const GLvoid *p)
```
- *size* - количество координат
- *type* - тип координат
- *stride* - смещение в байтах между соседними вершинами ( = 0 по дефолту)
- *p* - указатель на данные

##### Пример:

```
GLfloat arr[] = {
    1.0, 1.0, 0.2, 100.0, 200.0, 100.0,
    0.2, 0.3, 0.2, 300.0, 150.0, 300.0,
    ... // всего 6 строк
}; // первая тройка - цвета, вторая - вершины

glColorPointer(3, GL_FLOAT, 6 * sizeof(GLfloat), &arr[0]);

glVertexPointer(3, GL_FLOAT, 6 * sizeof(GLfloat), &arr[3]);
```

**Шаг 3.** Разыменование (в смысле извлечения)

3.1 Разыменование элемента

```
void glArrayElement(GLint idx); //получает idx из всех массивов
```

#####  Пример:
```
glEnableClientState(GL_VERTEX_ARRAY);
glVertexPointer(...);
glEnableClientState(GL_COLOR_ARRAY);
glColorPointer(...);
glBegin(...);
    glArrayElement(...);
    ...
glEnd();
```

3.2 Разыменование по списку

```
glDrawElements(GLenum mode, GLsizei count,  GLenum type,  const GLvoid *indices)
```

- *mode* - тип примитива
- *count* - число элементов, индексы которых хранятся в indices
- *type* - тип элементов indices
- *indices* - индексы вершин

Эквивалентно:

```
glBegin(mode);
    for (int i = 0; i < count; i++)
    {
        glArrayElement(indices[i]);
    }
glEnd();
```

##### Пример:

![](https://raw.githubusercontent.com/ShAlinaShulgina/ComputerGraphics/master/pic/qub.png)

```
frontInd[] = {4, 5, 6, 7};
// таких 6 (граней  - 6)
glDrawElements(GL_QUADS, 4, GL_UNSIGNED_BYTE, frontInd);
// и таких 6
```

##### Пример:

```
oneInd[] = {0, 1, 2, 3, 4, 5, 6};
twoInd[] = {7, 1, 8, 9, 10, 11};

glDrawElements(GL_LINE_STRIP, 7, ..., oneInd);
glDrawElements(GL_LINE_STRIP, 6, ..., twoInd);
```

```
glMultyDrawElements(GLenum mode,
                 	const GLsizei *count,
                 	GLenum type,
                 	const GLvoid **indices,
                 	GLsizei primcount);
```

Эквивалентно:

```
for (int i = 0; i < primcount, i++)
{
    if (count[i] > 0)
    {
        glDrawElements(mode, count[i], type, indices);
    }
}
```

3.3 Разыменование последовательности элементов массива

```
glDrawArrays(GLenum mode,  GLint first,  GLsizei count);
```

- *mode* - тип примитива
- *first* - начало
- заканчиваем: first + *count* - 1

Эквивалентно:

```
glBegin(mode);
    for(int i = 0; i < count; i++)
    {
        glArrayElement(first + i);
    }
glend();
```

```
void glMultiDrawArrays(GLenum mode,   GLsizei * count, GLint * first, void **indices, GLsizei primcount);
```

Эквивалентно:

```
for(int i = 0; i < primcount; i++)
{
    if (count[i] > 0)
    {
        glDrawArrays(mode, count[i], first, indices[i]);
    }
}
```

##### Смешанные массивы

```
void glInterleavedArrays(GLenum  format,
                         GLsizei stride,
                         const GLvoid  *p);
```

- *format* - показывает, какие массивы инициализировать
- *stride* - смещение в байтах
- *p* - данные

##### Пример:

```
GLfloat arr[] = {
    1.0, 1.0, 0.2, 100.0, 200.0, 100.0,
    0.2, 0.3, 0.2, 300.0, 150.0, 300.0,
    ... // всего 6 строк

// хотим активировать два массива и заполнить их из arr
glInterleavedArrays(GL_C3F_V3F, 0, arr);
```

#### 2. Группы атрибутов

Для каждого примитива свой набор атрибутов.

```
// сохраняет все атрибуты, которые оепределяются маской в стеке атрибутов
glPushAttrib(GLbitfield mask);

// извлекает из стека аттрибутов
glPopAttrib();
```

- **GL_LINE_BIT** - атрибуты линии
- **GL_POINT_BIT** - атрибуты точки
- ...

##### Пример:

```
glLineWidth(...);
...
glLineStipple(...);

glPushAttrib(GL_LINE_BIT); // ~ сохранение состояния

...
glLineWidth(...);
glPopAttrib();
```
 Каждый  **push** должен иметь последующий **pop**.


## Тема: Освещение

#### 1. Введение

Нас будут интересовать интенсивность и цвет. Освещение позволяет сделать нам объемное отображение.

#### 2. Типы света

1. Фоновый (ambient) - свет, поступающий с неопределенного направления и, отражаясь, выходит в неопределенном направлении.
2. Рассеянный (diffuse) - свет, поступающий из одного направления и отражается в разных направлениях. Чем больше угол падения, тем на поверхности он ярче, чем меньше, тем свет заметен меньше.
3. Отраженный (specular) или зеркальный - свет, поступающий и отраженный в одном направлении.
4. Излучаемый (emmisive) - свет, который излучает сама поверхность, при этом поверхность называется самоизлучающей.

Любой свет содержит три компоненты:
* фоновую
* рассеянную (диффузную)
* отраженную

#### 3. Цвет материала

Согласно модели OGL цвет материала задается в зависимости от того, какой процент приходящего света поверхность отражает.
Цвет материала как и свет имеет три компоненты (3 цвета):
* фоновую
* рассеянную (диффузную)
* отраженную

#### 4. Значения RGB для источников света и материала

Для источника света значение RGB зависит от процентной доли полной интенсивности каждого цвета.
Для материалов значения RGB беруется из отражающей способности каждого цвета. Если мы ставим:
r = 1.0 то будет полностью отражаться красный цвет
g = 0.5 то зеленый будет отражатся 50%

```
Пусть для источников света: LR, LG, LB
    а для источников материала: MR, MG, MB
Тогда (LR * MR, LG * MG, LB * MB)

Пусть для источника 1: LR1, LG1, LB1
Пусть для источника 2: LR2, LG2, LB2
(LR1 + LR2, LG1 + LG2, LB1 + LB2)
```

#### 5. Алгоритм добавления света в сцену

1. **Определение нормалей для каждой вершины каждого объекта**


```
glNormal<размерность><тип[опционально векторная форма]>(...);
```
Устанавливает текущий вектор нормали согласно аргументам.

##### Пример

```
glBegin(GL_POLYGON);
    glNormal3fv(h0);
    glNormal3fv(v0);
    glNormal3fv(h1);
    glNormal3fv(v0);
    ...
glEnd();
```
Перед вычисление освещенности все вектора автоматически нормализуются (т.е. приводятся к единичному вектору).
Если используется масштабирование, то нормализацию следует проводить вручную.
Как преобразовать вручную:

```
glEnable(GL_NORMALIZE);

// менее затратная нормализация
glEnable(GL_RESCALENORMAL); //однородное масштабирование
```

2. **Создание источника света**

Максимальное количество источников света - 8.
Для управления свойствами источника света используются команды glLight{i f}v:

```
glLightf(GLenum light, GLenum pname, GLfloat param);
glLightfv(GLenum light, GLenum pname, const GLfloat *param);
```

Параметр light указывает OpenGL для какого источника света задаются параметры. Команда glLightf используется для задания скалярных параметров, а glLightfv используется для задания векторных характеристик источников света.

[Light](http://compgraphics.info/OpenGL/lighting/light_sources.php)

Имя параметра | Значение по умолчанию                         | Краткий комментарий
--------------|-----------------------------------------------|-----------------------------------------------------------------------------------------------------------------
GL_AMBIENT    | (0.0, 0.0, 0.0, 1.0)                          | цвет фонового излучения источника света
GL_DIFFUSE    | (1.0, 1.0, 1.0, 1.0) или (0.0, 0.0, 0.0, 1.0) | цвет рассеянного излучения источника света (значение по умолчанию для GL_LIGHT0 - белый, для остальных - черный)
GL_SPECULAR   | (1.0, 1.0, 1.0, 1.0) или (0.0, 0.0, 0.0, 1.0) | цвет зеркального излучения источника света (значение по умолчанию для GL_LIGHT0 - белый, для остальных - черный)

##### Пример

```
GLfloat light_ambient[] = {0.0, 0.0, 0.0, 0.1};
GLfloat light_dif[] = {1., 1., 1., 1.};

glLightfv(GL_LIGHT0, GL_AMBIENT, light_ambient);
glLightfv(GL_LIGHT0, GL_DIFFUSE, light_dif);
```

##### Типы источников света:

* точечные (позиционные, направленные (бесконечно удаленные))
* прожектор (поток света ограничен конусом)
* фоновый

```
glLight3fv(GL_LIGHT0, GL_SPOT_CUTOFF, alpha);
glLight3fv(GL_LIGHT0, GL_SPOT_DIRECTION, ...);
glLight3fv(GL_LIGHT0, GL_CONSTANT_ATTENUATION, ...);
```

3. **Задание модели освещения**

Аспекты:

  1. Интенсивность общего фонового освещения
  2. Пололжение точки обзора
  3. Расчет освещенности для лицевых и обратных граней
  4. Флаг, определяющий необходимость отделения отраженного цвета от других состовляющих (важно при текстурировании)

```
glLightModel{if}[v](GLenum pname, param);
// param - перечисленные аспекты
```

4. **Определение материалов объектов**

```
glMaterial{if}[v](GLenum face, GLenum pname, param);
```

* *face* - может принимать три значения:
    - GL_FRONT
    - GL_BACK
    - GL_FRONT_AND_BACK
* *pname*
    - цвет компонента
    - GL_SHNINESS
    - GL_EMISSION
    - ...
* *param*

##### Пример

```
int main()
{
    ...
    init();
    glDisplayFunc(display);
    ...
    return 0;
}

display()
{
    ...
}

init()
{
        glClearColor(0., 0., 0.);
        glMaterialfv(GL_FRONT, GL_SPECULAR, mat_spec);
        glLightfv(GL_LIGHT0, GL_POSITION, light_pos);
        glLightfv(GL_LIGHT0, GL_DIFFUSE, white_light);
        glLightModel(GL_LIGHT_MODEL, GL_AMBIENT, amb);

        glEnable(GL_LIGHTING);
        glEnable(GL_LIGHT0);
        ...
}

```

## Тема: Визуализация

#### 1. Введение

Аналогия с фотографией.

Фото                                     | Виртуальная сцена
-----------------------------------------|----------------------------------------------------------
Настрока сцены модели                    | Модельные преобразования
Фиксация фотоаппарата                    | Видовые преобразования
Настройка фотоаппарата (объектива)       | Преобразование проецирования (выбор и настройка проекции)
Определение размера итогового фотоснимка | Настрока (задание) окна просмотра (viewport)

Стадии преобразования вершин:

Объектные координаты (x, y, z, w) -> Модельно-видовая матрица -> Система координат наблюдателя -> Матрица проецирования -> Отсечение кординат -> Перспективное деление -> Нормализация координат -> Преобразование обзорной точки -> Оконные координаты

![](https://raw.githubusercontent.com/ShAlinaShulgina/ComputerGraphics/master/pic/view.png)

#### 2. Команды общего назначения

```
glMatrixMode(GLenum);
\\ GLenum - имя матрицы
    GL_MODELVIEW
    GL_PROJECTION
    GL_TEXTURE
```

```
glLoadIdentity(void); //установка текущей матрицы в единичную
```

Лучше glMatrixMode и glLoadIdentity использовать в связке.

```
glLoadMatrix{fd}(*m); \\ 4 x 4
glMultMatrix{fd}(*m);
```

C/C++:
m[4][4]; //первая 4 строка, вторая столбец
OpenGL раборает в другом порядке, сначала у нее стоблец, а потом строка
Можно транспонировать матрицу перед использованием, или задавать одномерным вектором.
```
glLoadTransposeMatrix
glMultTransposeMatrix
```

#### 3. Система фиксированных координат vs. локальная система координат

```
glMatrixMode(GL_MODELVIEW);
glLoadIdentity();
glMultMatrix(T); // перемещение
glMultMatrix(R); // поворот
drawObject();
```

#### 4. Модельные преобразования

- это преобразования, связанные со сценой.

1. Масштабирование **glScale**
2. Поворот **glRotate**
3. Параллельный перенос **glTranslate**

Они ортогональны и нельзя с помощью одного сделать другое.

##### glTranslate
- умножает текущую матрицу на матрицу, которая перемещает объект с помощью значений x, y, z.

```
glTranslate{fd}(x, y, z);
```

##### glRotate
- умножает текущую матрицу на матрицу, осуществляющую поворот _против часовой стрелки_ на угол **angle** вокруг луча из начала координат в точку (x, y, z). Объект, располагающийся дальше от оси вращения, будет повернут сильнее (у него больше орбита вращения), чем объект, который располагается ближе к оси вращения.

```
glRotate{fd}(angle, x, y, z);
```

##### glScale
- умножает текущую матрицу на матрицу, осуществляющую растяжение, сжатие и зеркальное отображение относительно осей.

```
glScale{fd}(x, y, z);
```
Области определения аргументов _x, y, z_:

Значение  | Событие
----------|---------------------
\> 1      | Растяжение
== 1      | Ничего не происходит
< 1, \> 0 | Сжатие

#### 5. Видовые преобразования

Иногда можно некоторые видовые преобразования осуществить с помощью модельных преобразований. Для этого подойдут функции:

```
glTranslate(...);
glRotate(...);
```

Функция задания точки наблюдения.
```
gluLookAt(GLdouble eyeX,
          GLdouble eyeY,
          GLdouble eyeZ,
          GLdouble centerX,
          GLdouble centerY,
          GLdouble centerZ,
          GLdouble upX,
          GLdouble upY,
          GLdouble upZ);
```

#### 6. Преобразования проецирования

Перспективная проекция - объекты, находящиеся дальше, становятся меньше.

```
glFrustum(GLdouble left,
          GLdouble right,
          GLdouble bottom,
          GLdouble top,
          GLdouble nearVal,
          GLdouble farVal);
```

Параметры       | Значение
----------------|---------------------------------------------------------------------------------------------------------
left, right     | Координаты левой и правой вертикальных плоскостей отсечения.
bottom, top     | Координаты нижней и верхней горизонтальных плоскостей отсечения.
nearVal, farVal | Расстояния до ближней и дальней плоскостей отсечения глубины. Оба расстояния должны быть положительными.

```
gluPerspective(GLdouble fovy,
               GLdouble aspect,
               GLdouble zNear,
               GLdouble zFar);
```

Параметры | Значение
----------|-------------------------------------------------------------------------
fovy      | Угол зрения (0, 180).
aspect    | Отношение сторон усеченной пирамиды видимости, а имеено ширины к высоте.
zNear     | Расстояние до близжайшей плоскости.
zFar      | Расстояние до дальней плоскости.

Ортогональная проекция:
- объем видимости ограничивается параллелепипедом

```
glOrtho(GLdouble left,
        GLdouble right,
        GLdouble bottom,
        GLdouble top,
        GLdouble nearVal,
        GLdouble farVal);
```

#### 7. Преобразования окна просмотра

```
glViewport(GLint x,
           GLint y,
           GLsizei width,
           GLsizei height);
```

Парамерт      | Значение
--------------|---------------------------------------------------------------------------------------
x, y          | Нижний левый угол прямоугольника видового экрана в пикселях. Начальное значение (0,0).
width, height | Ширина и высота окна просмотра.

`` glViewport(0, 0, winWidth, winHeight); ``

#### 8. Управление стеком матриц

В случае если надо, например, повернуть один объект сцены, а другой оставить неподвижным, удобно сначала сохранить текущую видовую матрицу в стеке командой **glPushMatrix()**, затем вызвать glRotate..() с нужными параметрами, описать примитивы, из которых состоит этот объект, а затем восстановить текущую матрицу командой **glPopMatrix()**.

## Тема: Текстурирование

Текстура - прямоугольный массив данных. Данные:
- цвета
- яркость
- альфа-каналы

Единица текстуры - **тексель**.
Текстуры усложняются и возникают проблемы с приминением, когда поверхности не являются стандартными.
В зависимости от поверхности, тектуры могут различаться и методы использования могут меняться.

#### 1. Алгоритм работы с текстурами

**1.** Определение объекта текстуры и привязка к нему данных текстуры.

Виды текстур:
- одномерные
- двумерные (НАШИ)
- трехмерные
- кубические

Шаги:
1) определение (генерация) имени объекта текстуры
2) привязка текстуры к объекту


**2.** Определение того, как текстура будет применима к каждому пикселю.

Способы взаимодействия текстуры и пикселя (текселя <-> пикселя):
1) замещение (тексель полностью замещает фрагмент)
2) модуляция (масштабирование) цвета фрагмента (при освещении)
3) смешивание исходного цвета фрагмента и текселя

**3.** Включение режима наложения текстур.

```
glEnable(GL_TEXTURE_1D);         |
         GL_TEXTURE_2D           |
         GL_TEXTURE_3D           |
         GL_TEXTURE_CUBE_MAP    \ /
```
```
glEnable(GL_TEXTURE_2D);
glEnable(GL_TEXTURE_1D);
```
**Всегда будет включаться старшая.**

**4.** Отрисовка сцены с использованием как координат объекта, так и координат текстур.

При отрисовки сцены нужно использовать не только координаты объекта, но и координаты текстуры.
Размеры текстуры должны быть степенью двойки.
##### Пример
```
#define width 64 //ширина текстуры
#define height 64 //высота текстуры

static GLubyte image[][];
static GLuint texName;

void makeImage(void)
{
    //создание текстуры image
}

void init(void)
{
    glClearColor(0.0, 0.0, 0.0, 0.0);
    //генерация названия текстуры для одной текстуры
    glGenTextures(1, &texName);
    //создание и актуализация необходимой текстуры
    glBindTexture(GL_TEXTURE_2D, texName);
    makeImage();
    //выравнивание данной текстуры по строкам относительно начала строки
    glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
    //определяет свойства той текстуры, которую мы загружаем через свойства объекта
    glTexImage2D(GL_TEXTURE_2D,     //type
                 0,                 //level - используется когда мы хотим использовать несколько вариантов текстур
                 GL_RGBA,           //указывает какие компоненты цвета выбраны для текселя текстуры
                 width,
                 height,
                 0,                 //ширина рамки
                 GL_RGBA,           //указывает какие компоненты цвета выбраны для текстуры в целом
                 GL_UNSIGNED_BYTE,
                 image);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_P, GL_REPEAT);
}

void display(void)
{
    glTexEnvf(GL_TEXTURE_ENV,
              GL_TEXTURE_ENV_MODE,
              GL_REPLASE);
              //GL_MODULATE
              //...
    glEnable(GL_TEXTURE_2D);
    glBindTexture(GL_TEXTURE_2D, texName);
    glBegin(GL_QUADS);
        glTexCoord2f(0.0, 0.0);
        glVertex3f(-2.0, -1.0, 0.0);
        glTexCoord2f(0.0, 1.0);
        glVertex3f(-2.0, 1.0, 0.0);
        glTexCoord2f(1.0, 0.0);
        glVertex3f(2.0, -1.0, 0.0);
        glTexCoord2f(1.0, 1.0);
        glVertex3f(2.0, 1.0, 0.0);
    glEnd();
    glDisable(GL_TEXTURE_2D);
}
```

###### Фильтрование текстур:

**GL_NEAREST** (также называемый фильтр ближайшего соседа) — стандартный метод фильтрования в OpenGL. Пока он установлен OpenGL будет выбирать пиксель, который находится ближе всего к текстурной координате.
![](https://hsto.org/files/08d/3ac/382/08d3ac38282a423ea9d4d3a291c3f93d.png)
**GL_LINEAR** (также называемый (би)линейной фильтрацией). Принимает интерполированное значение от ближайших к текстурной координате текселей. Чем ближе тексель к текстурной координате, тем больше множитель цвета этого текселя.
![](https://hsto.org/files/af8/890/e26/af8890e261f24f4b9dc3d813ecc62202.png)

###### Texture Wrapping:

* **GL_REPEAT**: Стандартное поведение для текстур. Повсторяет текстуру.
* **GL_MIRRORED_REPEAT**: Похоже на GL_REPEAT за исключением того, что в этом режиме изображение отражается.
* **GL_CLAMP_TP_EDGE**: Привязывает координаты между 0 и 1. В результате выходящие за пределы координаты будут привязаны к границе текстуры.
* **GL_CLAMP_TO_BORDER**: Координаты, выходящие за пределы диапазона будут давать установленный пользователем цвет границы.

#### Загрузка текстуры из файла

```
#include <glaux.h>
AUX_RGBImageRec picFromeFile = auxDIPImageLoad(...);
```

#### Удаление объектов текстур

```
void glDeleteTextures(n, *texNames);
```
Аргумент | Значение
---------|------------------------------------------------
n        | Specifies the number of textures to be deleted.
textures | Specifies an array of textures to be deleted.

## Тема: Смешивание

#### 1. RGBA
    A - альфа-канал, степень прозрачности цвета.

```
glColor(...);
glClearColor(...);
```

- Альфа-канал задействован только тогда, когда включен режим смешивания.
- Смешивание происходит во время растеризации, но до записи информации в буфер кадра.
- Если режим смешивания выключен, то данные в буфере кадра перезаписываются и никакой прозрачности не будет.
- Диапазон значений [0,1].

#### 2. Факторы влияния источника и получателя

Факторы влияния - коэффиценты, которые умножатся на RGBA компоненты источника и получателя.
После применения факторов влияния компоненты источника и получателя попарно объединяются (способ объединения можно выбрать).

(Sr, Sg, Sb, Sa) - (Rs, Gs, Bs, As);
(Dr, Dg, Db, Da) - (Rd, Gd, Bd, Ad);
1) (SrRs+DrRd, SgGs+DgGd, SbBs+DbBd, SaAs+DaAd);
2) Приведение к [0,1]

```
// задает функцию смешивания цветов
void glBlendFunc(GLenum sfactor, GLenum dfactor);
```
sfactor и dfactor определяют способ вычисления факторов влияния.

GLenum sfactor - имя функции для обработки входящего цвета.
GLenum dfactor - функция используемая для обработки предыдущего цвета (цвета в буфере кадра).

```
void glBlendFuncSeparate(GLenum srcRGB,
                         GLenum dstRGB,
                         GLenum srcAlpha,
                         GLenum dstAlpha);
```

```
GL_*CONSTANT*
```

```
void glBlendColor(GLclampf red,
                  GLclampf green,
                  GLclampf blue,
                  GLclampf alpha);
```

#### 3. Включение/выключение режима смешивания

```
glEnable(GL_BLEND);
...
glDisable(GL_BLEND);
//Еще один способ получение того же результата без отключения режима смешивания
glBlendFunc(GL_ONE, GL_ZERO);
```

#### 4. Объединение пикселей на основе выражения

```
// Задает способ смешивания RGBA компонент источника и получателя
void glBlendEquation(GLenum mode);
```

![GLenum mode](https://raw.githubusercontent.com/ShAlinaShulgina/ComputerGraphics/master/pic/glBlendEquation.png)

```
glClearColor(1.0, 1.0, 0.0, 0.0);
glColor(0.0, 0.0, 1.0);

GL_FUNC_ADD:
    (1.0, 1.0, 0.0) + (0.0, 0.0, 1.0) = (1.0, 1.0, 1.0);
    // белый объект на желтом фоне

GL_FUNC_REVERSE_SUBTRACT:
    (1.0, 1.0, 0.0) - (0.0, 0.0, 1.0) = (1.0, 1.0, -1.0) = (1.0, 1.0, 0.0);
    // желтый объект и фон

GL_FUNC_SUBTRACT:
    (0.0, 0.0, 1.0) - (1.0, 1.0, 0.0) = (-1.0, -1.0, 1.0) = (0.0, 0.0, 1.0);
    // голубой объект на желтом фоне
```

#### 5. Область применения смешивания

1) Итоговое изображение: половина одного изображения + половина другого.

- scrFactor: GL_ONE
- destFactor: GL_ZERO
- рисуем 1 объект
- srcFactor: GL_SRC_ALPHA
- destFactor: GL_ONE_MINUS_SRC_ALPHA
- рисуем второй объект с alpha = 0.5

2) Итоговое изображение: три рисунка на фоне каждый с прозрачностью 0.33

- destFactor: GL_ONE
- srcFactor: GL_SRC_ALPHA
- рисуется каждый рисунок с alpha = 0.33

#### 6. Смешивание с использованием буфера глубины
Буфер глубины хранит расстояние от точки обзора до ближайших (видимых) точек объекта.
Алгоритм:
- сначала рисуются все непрозрачные объекты;
- буфер переводится в режим чтения;
- рисуем прозрачные объекты;

```
// enable or disable writing into the depth buffer
void glDepthMask(GLboolean flag);
//If flag is GL_FALSE, depth buffer writing is disabled.
```

## Тема: Списки отображения

![](https://github.com/ShAlinaShulgina/ComputerGraphics/blob/master/pic/Conveyor.png?raw=true)

*Список отображения (дисплейный список):*
- два варианта хранения данных - список отображения и непосредственный режим (данные как есть);
- информация обрабатывается точно так же, как в непосредственном режиме;
- актуальны при использовании больших наборов данных.

Список отображения (display list) - удобный, эффективный способ именования и организации набора команд OGL.

```
//идентификатор списка
GLuint theTorus;

void drawTorus()
{
    glBegin(GL_QUADR_STRIP);
        for (...)
        {
            ...
            glVertex3f(...);
        }
    glEnd();
}

void init()
{
    //инициализация идентификатора
    //glGenLists(1) генерация
    theTorus = glGenLists(1);
    glNewList(theTorus, GL_COMPILE);
        drawTorus();
    glEndList();
}

void display()
{
    ...
    glCallList(theTorus);
}
```
**Пояснения:**
1. Созданиие и выполнение списка
```
glNewList();
...
glEndList();
```
Обе функции работают в сзязке. Если задать только конец, то компилятор выдаст ошибку.

##### Пример
```
GLuint listName;

void init()
{
    listName = glGenList(1);
    glNewList(listName);
        glColor3f(1.0, 0.0, 0.0);
        glBegin(GL_TRIANGLES);
            ...
        glEnd();
        glTranslate3f(1.5, 0.0, 0.0); //перемещение по Ox на 1.5
    glEndList();
}

void drawLine()
{
    glBegin(GL_LINES);
        ...
    glEnd();
}

void display()
{
    glColor(0.0, 1.0, 0.0);
    for(int i = 0; i < 10; i++)
    {
        glCallList(listName);
    }
    drawLine();
    //линия бдет красной
    //и как и треугольники будет повернута на 1.5 по Ox
}
```
Одновременно может быполняться только одина список отображения. Нельзя вложить один список в другой.

2. Присвоение имени списку и его создание
Функция позволяет генерировать уникальные неиспользуемые индексы:
```
GLuint glGenLists(GLsizei range);
// range - диапазон
// возвращает целое число - начало блока ииндексов,
// если возвращает 0 - то выделить не может
```
Функция создания или замены списка отображения:

```
void glNewList(GLuint list, GLenum mode);
```

**list** - идентификатор
**mode**:
    - _GL_COMPILE_ - используется, когда необходимо, чтобы команды OGL обрабатывались во время их размещения в списке
    - _GLCOMPILEAND_EXECUTE_ - используется, когда необходимо, чтобы команды, до помещения их в список, выполнялись в непосредственном режиме

3. Вызов списка
Функция вызова списка:

```
void glCallList(GLuint list);
```

Когда разрушается контекст программы список тоже разрушается.
Список нельзя никуда сохранить, он существует только в контексте программы.
4. Удаление списка
Функция удаляет набор списков с последовательными индексами. Начиная с _list_ в количестве _range_.
При попытке удаления несуществующего списка ничего не происходит. После удаления, удаленный индекс становится доступен.

```
void glDeleteLists(GLuint list, GLsizei range);
```

## Гиренко Дмитрий Владимирович
## Компьютерная графика

## Тема: Введение в компьютерную графику ч.1

#### 1. Области применения КГ.

**КГ** - область информатики, в сферу интересов которой входят все аспекты формирования изображения.

**Области применения:**
1. моделирование
2. проектирование
3. GUI
4. представление

```
CLI - comand line interface <-> GUI
```
#### 2. Изображение и его виды.
**Виды изображений:**
* реалистичное или физическое (глаз, фотоаппарат)
* синтезируемое - продукт КГ

**Особенности формирования:**
1. физическое: объект, субъект и соответствие
2. синтезируемое:
    1. объект - то, что моделируем, сцена
    2. виртуальная камера (некий посредник)
    3. источники света добавляются в сцену (отдельный программный объект)

#### 3. Графическая система.

**Система КГ** - вычислительная система общего назначения (с расширенной функциональностью отдельных компонент).

![](https://github.com/ShAlinaShulgina/ComputerGraphics/blob/master/pic/%D0%9A%D0%93.png?raw=true)

**Буфер кадра и пиксели:**
Все современные графические системы использую растровый способ создания изображения:
  * изображение - массив точек (изображение дискретно);
  точки называются пикселями (px);
  растр - это массив точек;
  * каждый пиксель имеет четко определенное положение на экране (пиксели локализованы)
  * массив кодов зацветки пикселей хранится в буфере кадров (frame buffer)
  * под код буфера кажда может выделяться отдельная память (VRAM || DRAM)

**Характеристики буфера кадра:**
1. глубина (depth) - количество бит, выделенных отдельному коду зацветки пикселя (как много информации о цвете пиксель может хранить)

1 бит  | 2 цвета
--|--
8 бит  | 2^8 цветов
16 бит  |  2^16 цветов
 > 24 бит  |  true-color
2. разрешающая способность (разрешение)

В простых графических системах используется один процессор, на который возлагаются все **задачи КГ:**
1. формирование примитивов (точки, линии, треугольники, ...)
2. проецирование (изначально x,y,z -> проецируется на плоский экран x,y)
3. растровое преобразование (перевод в коде зацветки пикселя)

Для ускорения процесса подзадачи 1-3 могут выносится в отдельный процессор.

## Тема: Введение в компьютерную графику ч. 2

#### 1. Интерфейс прикладного программиста.

![](https://github.com/ShAlinaShulgina/ComputerGraphics/blob/master/pic/API.png?raw=true)

**Интерфейс прикладного программиста (API)** - множество функций, которые образуют графическую библиотеку; спецификация этих функций - API (интерфейс между прикладной программой и графической системой).
Графичекий API - наш интерес.

**API должен обеспечивать работу с:**
- объектами
- наблюдателями (виртуальная камера)
- источники света
- материал объекта

**Характеристики графического API:**
1. Объекты описываются массивами вершин. Вершина - абстрактное вспомогальное понятие. Существует набор примитивов:
    - точки
    - отрезки
    - треугольники
    - многоугольники
    - сферы
    - и т.д.
2. Повороты, перемещение, масштабирование.
3. Источники света. Доступны разные типы - точечный, прожектор и фоновый. Существует возможность регулирования оптических свойств, яркости, интенсивности.
4. Существует возможность задания глянцевой или матовой поверхности, цвета и степени неровности.

**Парадигра "моделирования - тонирования".** Существует две концепции формирования изображения:
1. Модель минтезируемой камеры.
Сразу формируется готовое изображение, смоделированное и в цвете.

2. Моделирование-тонирование.
Сначала моделируется  бесцветная сцена, а затем тонируется *(rendering)* (связка через промежуточные файлы)

#### 2. Архитектура графической системы.

0. Архитектура Фон-Неймана. Процессор - многофункционален.

1. Дисплейный процессор - отдельный процессор в составе дисплея. Задачи:

    - регенирация изображения;

    - формирование примитивов;

2. Конвейерная архитектура (СБПС - плата). В данной архитектуре формирование изображения разбивается на четыре этапа:

    1. геометрические преобразования - формирование *представления объектов* сцены в разных системах координа; используется аппарат линейной алгебры (матричной математики)

    2. отсечение (clipping) - процесс происходит с использованием отсекающей прямоугольной рамки на плоскости проекции;
        1. объекты, проекции которых попадают во внутреннюю часть отсекающей рамки - учавствуют в формировании изображения;
        2. объекты, которые пересекают отсекающую рамку - учавствуют частично;
        3. остальные отсекаются

    3. проективные преобразования - переход с объемной сцены в плоскую, виды:
        - перспективная;
        - ортогональная;
        - косоугольная

    4. растровые преобразования - преобразования описания двумерных объектов в коды зацветки пикселей **(px)** в буфере кадра.

**Производительность графического конвейера:**

В рассматриваемой структуре обработки графической информации исользуются операции двух типов. На начальной стадии - операции с координатами вершин - числа с плавающей точкой. Все операции после растрового преобразования требуют выполнения побитовых операций на уровне содержимого буфера кадра.

Произведение графического конвейера = производительность при работе с плавающей точкой + производительность при побитоых операциях

Для оптимизации эти два процесса разносятся по разным платам.

## Тема: Начало OpenGL

#### 1. Прикладной интерфейс OpenGL (OGL)

![](https://github.com/ShAlinaShulgina/ComputerGraphics/blob/master/pic/IOGL.png?raw=true)

Категории функций OGL:
1. функции работы с примитивами (primitive functions)
2. функции работы с атрибутами (attribute functions) (изменить цвет, прозрачность)
3. функции визуализации (view functions) (как будет отображаться сцена)
4. функции геометрических проеобразований (transform functions)
5. функции ввода графической интформации (input functions) (в плане назначения)
6. управляющие функции (control functions)

Интерфейсы OGL:
- функции предворяются префиксом 'gl'
- GL - основная библиотека (база)
- дополнительные библиотеки:
    - GLU - предназначена для работы с формированием сложных объектов
    - GLUT - набор функция для работы с окнами
- для читабельности программы введено использование маркосов с профексом 'GL_' (в .h файлах)

Атрибуты OpenGL:
![](https://github.com/ShAlinaShulgina/ComputerGraphics/blob/master/pic/GL.png?raw=true)

#### 2. OpenGL как конечный автомат

OGL работает по принципу **конечного автомата**. Пользователь переводит его в различные состояния или режимы, в котором он останется до момента следующего изменения. Многие параметры состояния связаны с режимами, которые включаются и выключаются командами:
- glEnabel()
- glDisable()
    - Компонент состояния
    - Состояние - набор компонентов состояний
    - Режим

#### 3. Конвейер OpenGL

![](https://github.com/ShAlinaShulgina/ComputerGraphics/blob/master/pic/Conveyor.png?raw=true)

*Список отображения (дисплейный список):*
- два варианта хранения данных - список отображения и непосредственный режим (данные как есть);
- информация обрабатывается точно так же, как в непосредственном режиме;
- актуальны при использовании больших наборов данных.

*Блок оценки (вычислитель):*
- все геометрические примитивы описываются вершинами;
- параметрические кривые/поверхности могут быть описаны контрольными точками и многочленами (базисными функциями);
- генерирует вершины по заданным базисным функциям и контрольными точкам.

*Операции с вершинами:*
- преобразуют вершины в примитивы;
- проецирование сцены;
- преобразование координат текстур;
- вычисление цвета при использовании освещения.

*Компоновка примитивов:*
- отсечение;
- компоновка примитивов.

*Операции с пикселями:*
- растровые обрабатываются параллельно вершинам;
- пиксели из системной памяти распаковываются в некоторое количество компонентов, данные масштабируются, трансформируются, и обрабатываются как пиксельные карты;
- пиксельные карты или накапливаются в памяти текстур, или отправляются на растеризацию;
- если данные забираются из буфера кадра, то выполняется ряд операций по пересылке этих пикселей;
- данные из буфера кадра записываются в системную память.

*Компоновка текстур:*
- если текстур несколько, то они помещаются в текстурные объекты.

*Операции с пикселями, Растеризация:*
- преобразование векторных и растровых данных в фрагменты.

*Операции с фрагментами:*
- текстурирование, тексели;
- каждый тексель накладывается на соответсвующий фрагмент;
- специфические функции (прозрачность, эффекты);
- фрагменты записываются в буфер кадра;
- растровые данные преобразуются в коды засветки пикселей.

## Тема: OpenGL. Основы рисования; примитивы, атрибуты.

#### 1. Пояснение

Что такое примитив?
Нет строгого разграничения.

В OpenGL, примитивы в базовой библиотеке GL:
- точка;
- отрезок;
- треугольники;
- 4-хугольник;
- n-угольник;
- текст.

Более сложные примитивы в библиотеке GLU:
- сфера;
- шар.

#### 2. Рисование примитивов

**Вершины:**

- любой объект задается списком вершин;
- **gl**Vertex - функции работы с вершинами предваряются данной конструкцией (формат команды задания вершины);
- **gl**Vertex... , на **...** стоят:
    - размерность - цифра;
    - тип данных координат:
        - d - целочисленные
        - f -  плавающая точка

Пример:
```
glVertex2d(2, 5); - 2-мерная целочисленная
glVertex3f(2.3, 3.21, 10.0) - 3-мерная плавающая точка

v = ... // вектор
glVertex2dv(v)
```

**Формат задания объектов:**

- операторные скобки необходимы для отрисовки объектов
```
glBegin(...);
    glVertex...;
    glVertex...;
glEnd();
```
- в glBegin(...) передается макрос, определяющий тип примитива
- между двумя операторными скобками располагаются команды задания вершин, также могут быть включены некоторые другие команды OGL (не все). Причем, исключения не всегда генерируются (можете не получить ошибку):
    - функции атрибутирования;
    - ... (см. спецификацию)
    - любые конструкции языка программитрования

**Примитивы:**

*Основное различие примитивов* - наличие внутренней области (три линии и треугольник).

1. Точки (GL_POINTS)
```
glBegin(GL_POINTS);
    glVertex2d(2, 3);
    glVertex2d(4, 5);
glEnd(); // получим просто две точки
```
2. Линии (GL_LINES)
```
glBegin(GL_LINES);
    glVertex2d(2, 3);
    glVertex2d(4, 5);
glEnd(); // получим линию через две точки
// если задать четыре точки то будет две линии
```
3. Ломанная линия (GL_LINE_STRIP)
```
glBegin(GL_LINE_STRIP);
    glVertex2d(2, 3);
    glVertex2d(4, 5);
    glVertex2d(10, 6);
glEnd(); // получим ломанную линию через три точки
```
4. Циклическая линия (GL_LINE_LOOP)
```
glBegin(GL_LINE_STRIP);
    glVertex2d(2, 3);
    glVertex2d(4, 5);
    glVertex2d(10, 6);
glEnd(); // получим замкнутую ломанную линию
```
5.  Многоугольники (полигоны)
Особенности:
    - есть внутренняя область, с которой можно работать;
    - используются для апроксимации криволинейных поверхностей;
    - внутренняя область может:
        - тонироваться;
        - текстурироваться;
        - маска (паттерн, шаблон);
    - для корректного отображения внутренней области он должен обладать свойствами, быть:
        - простым (не очень много вершин);
        - выпуклым;
        - плоским;

Типы многоугольников:

5.1. Треугольники (GL_TRIANGLES)

5.2. Четырехугольники (GL_QUADS)

5.3. Некий многоугольник (GL_POLYGON)

5.4. Полосы (GL_TRIANGLE_STRIP, GL_QUADR_STRIP)

![Полоса треугольников](https://github.com/ShAlinaShulgina/ComputerGraphics/blob/master/pic/GL_TRIANGLE_STRIP.png?raw=true)

5.5. Розетка (GL_TRIANGLE_FAN)


Общее представление:

![](https://github.com/ShAlinaShulgina/ComputerGraphics/blob/master/pic/fig.png?raw=true)

6. Криволинейные поврехности
    - апроксимация полигонами
    Тесселяция - мозайка из полигонов.
    - можно использовать готовые примитивы
    - кастомные функции (пользовательские)
    - задать функцию + опорные точки (вычислитель в конвейере)


7. Атрибуты (маска, толщина линии, цвет и т.д.)
Атрибут - любое свойство, которое определяет способ отображения любого примитива.
    - цвета
    - толщина (px)
    - маска (паттерн)
    - градиент

```
INSTALL
$ sudo apt-get update
$ sudo apt-get install libglu1-mesa-dev freeglut3-dev mesa-common-dev

MAKE
g++ main.cpp -o main -lglut -lGLU -lGL

RUN
./main

```


## Тема: Основы рисования: массивы вершин, группы атрибутов

 #### 1. Массивы вершин

1. Предопределены вершины в контексте OpenGl.
2. Можно хранить 8 типов данных - координаты, цвета, координаты текстуры
3. Упрощение работы с большим количеством вершин

Алгоритм использования:
1. Активация требуемого массива
2. Заполнение данными
3. Рисование на основе данных:
    - индивидуальный доступ к элементам
    - создание списков отдельных переменных
    - последовательная обработка элементов массива

**Шаг 1.** Активация массивов

```
glEnableClientState(GLenum array);
                    // GLenum
                    // GL_VERTEX_ARRAY
                    // GL_COLOR_ARRAY
                    // NORMAL
                    // всего 8 штук
glDisableClientState(GLenum array)
```
[glEnableClientState](https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glEnableClientState.xml)
```
Both glEnableClientState and glDisableClientState take a single argument, cap, which can assume one of the following values:

GL_COLOR_ARRAY
    If enabled, the color array is enabled for writing and used during
    rendering when glArrayElement, glDrawArrays, glDrawElements,
    glDrawRangeElements glMultiDrawArrays, or
    glMultiDrawElements is called. See glColorPointer.
GL_EDGE_FLAG_ARRAY
    If enabled, the edge flag array is enabled for writing and used during
    rendering when glArrayElement, glDrawArrays, glDrawElements,
    glDrawRangeElements glMultiDrawArrays, or
    glMultiDrawElements is called. See glEdgeFlagPointer.
GL_FOG_COORD_ARRAY
    If enabled, the fog coordinate array is enabled for writing and used during
    rendering when glArrayElement, glDrawArrays, glDrawElements,
    glDrawRangeElements glMultiDrawArrays, or
    glMultiDrawElements is called. See glFogCoordPointer.
GL_INDEX_ARRAY
    If enabled, the index array is enabled for writing and used during
    rendering when glArrayElement, glDrawArrays, glDrawElements,
    glDrawRangeElements glMultiDrawArrays, or
    glMultiDrawElements is called. See glIndexPointer.
GL_NORMAL_ARRAY
    If enabled, the normal array is enabled for writing and used during
    rendering when glArrayElement, glDrawArrays, glDrawElements,
    glDrawRangeElements glMultiDrawArrays, or
    glMultiDrawElements is called. See glNormalPointer.
GL_SECONDARY_COLOR_ARRAY
    If enabled, the secondary color array is enabled for writing and used
    during rendering when glArrayElement, glDrawArrays,
    glDrawElements, glDrawRangeElements glMultiDrawArrays, or
    glMultiDrawElements is called. See glColorPointer.
GL_TEXTURE_COORD_ARRAY
    If enabled, the texture coordinate array is enabled for writing and used
    during rendering when glArrayElement, glDrawArrays,
    glDrawElements, glDrawRangeElements glMultiDrawArrays, or
    glMultiDrawElements is called. See glTexCoordPointer.
GL_VERTEX_ARRAY
    If enabled, the vertex array is enabled for writing and used during
    rendering when glArrayElement, glDrawArrays, glDrawElements,
    glDrawRangeElements glMultiDrawArrays, or
    glMultiDrawElements is called.  See glVertexPointer.
```

**Шаг 2.** Помещение данных

```
// помещает данные в GL_VERTEX_ARRAY
void glVertexPointer(GLint size, GLenum type,
                     GLsize stride, const GLvoid *p);

glColorPointer(GLint size, GLenum type,
               GLsize stride, const GLvoid *p)
```
- *size* - количество координат
- *type* - тип координат
- *stride* - смещение в байтах между соседними вершинами ( = 0 по дефолту)
- *p* - указатель на данные

##### Пример:

```
GLfloat arr[] = {
    1.0, 1.0, 0.2, 100.0, 200.0, 100.0,
    0.2, 0.3, 0.2, 300.0, 150.0, 300.0,
    ... // всего 6 строк
}; // первая тройка - цвета, вторая - вершины

glColorPointer(3, GL_FLOAT, 6 * sizeof(GLfloat), &arr[0]);

glVertexPointer(3, GL_FLOAT, 6 * sizeof(GLfloat), &arr[3]);
```

**Шаг 3.** Разыменование (в смысле извлечения)

3.1 Разыменование элемента

```
void glArrayElement(GLint idx); //получает idx из всех массивов
```

#####  Пример:
```
glEnableClientState(GL_VERTEX_ARRAY);
glVertexPointer(...);
glEnableClientState(GL_COLOR_ARRAY);
glColorPointer(...);
glBegin(...);
    glArrayElement(...);
    ...
glEnd();
```

3.2 Разыменование по списку

```
glDrawElements(GLenum mode, GLsizei count,  GLenum type,  const GLvoid *indices)
```

- *mode* - тип примитива
- *count* - число элементов, индексы которых хранятся в indices
- *type* - тип элементов indices
- *indices* - индексы вершин

Эквивалентно:

```
glBegin(mode);
    for (int i = 0; i < count; i++)
    {
        glArrayElement(indices[i]);
    }
glEnd();
```

##### Пример:

![](https://raw.githubusercontent.com/ShAlinaShulgina/ComputerGraphics/master/pic/qub.png)

```
frontInd[] = {4, 5, 6, 7};
// таких 6 (граней  - 6)
glDrawElements(GL_QUADS, 4, GL_UNSIGNED_BYTE, frontInd);
// и таких 6
```

##### Пример:

```
oneInd[] = {0, 1, 2, 3, 4, 5, 6};
twoInd[] = {7, 1, 8, 9, 10, 11};

glDrawElements(GL_LINE_STRIP, 7, ..., oneInd);
glDrawElements(GL_LINE_STRIP, 6, ..., twoInd);
```

```
glMultyDrawElements(GLenum mode,
                 	const GLsizei *count,
                 	GLenum type,
                 	const GLvoid **indices,
                 	GLsizei primcount);
```

Эквивалентно:

```
for (int i = 0; i < primcount, i++)
{
    if (count[i] > 0)
    {
        glDrawElements(mode, count[i], type, indices);
    }
}
```

3.3 Разыменование последовательности элементов массива

```
glDrawArrays(GLenum mode,  GLint first,  GLsizei count);
```

- *mode* - тип примитива
- *first* - начало
- заканчиваем: first + *count* - 1

Эквивалентно:

```
glBegin(mode);
    for(int i = 0; i < count; i++)
    {
        glArrayElement(first + i);
    }
glend();
```

```
void glMultiDrawArrays(GLenum mode,   GLsizei * count, GLint * first, void **indices, GLsizei primcount);
```

Эквивалентно:

```
for(int i = 0; i < primcount; i++)
{
    if (count[i] > 0)
    {
        glDrawArrays(mode, count[i], first, indices[i]);
    }
}
```

##### Смешанные массивы

```
void glInterleavedArrays(GLenum  format,
                         GLsizei stride,
                         const GLvoid  *p);
```

- *format* - показывает, какие массивы инициализировать
- *stride* - смещение в байтах
- *p* - данные

##### Пример:

```
GLfloat arr[] = {
    1.0, 1.0, 0.2, 100.0, 200.0, 100.0,
    0.2, 0.3, 0.2, 300.0, 150.0, 300.0,
    ... // всего 6 строк

// хотим активировать два массива и заполнить их из arr
glInterleavedArrays(GL_C3F_V3F, 0, arr);
```

#### 2. Группы атрибутов

Для каждого примитива свой набор атрибутов.

```
// сохраняет все атрибуты, которые оепределяются маской в стеке атрибутов
glPushAttrib(GLbitfield mask);

// извлекает из стека аттрибутов
glPopAttrib();
```

- **GL_LINE_BIT** - атрибуты линии
- **GL_POINT_BIT** - атрибуты точки
- ...

##### Пример:

```
glLineWidth(...);
...
glLineStipple(...);

glPushAttrib(GL_LINE_BIT); // ~ сохранение состояния

...
glLineWidth(...);
glPopAttrib();
```
 Каждый  **push** должен иметь последующий **pop**.


## Тема: Освещение

#### 1. Введение

Нас будут интересовать интенсивность и цвет. Освещение позволяет сделать нам объемное отображение.

#### 2. Типы света

1. Фоновый (ambient) - свет, поступающий с неопределенного направления и, отражаясь, выходит в неопределенном направлении.
2. Рассеянный (diffuse) - свет, поступающий из одного направления и отражается в разных направлениях. Чем больше угол падения, тем на поверхности он ярче, чем меньше, тем свет заметен меньше.
3. Отраженный (specular) или зеркальный - свет, поступающий и отраженный в одном направлении.
4. Излучаемый (emmisive) - свет, который излучает сама поверхность, при этом поверхность называется самоизлучающей.

Любой свет содержит три компоненты:
* фоновую
* рассеянную (диффузную)
* отраженную

#### 3. Цвет материала

Согласно модели OGL цвет материала задается в зависимости от того, какой процент приходящего света поверхность отражает.
Цвет материала как и свет имеет три компоненты (3 цвета):
* фоновую
* рассеянную (диффузную)
* отраженную

#### 4. Значения RGB для источников света и материала

Для источника света значение RGB зависит от процентной доли полной интенсивности каждого цвета.
Для материалов значения RGB беруется из отражающей способности каждого цвета. Если мы ставим:
r = 1.0 то будет полностью отражаться красный цвет
g = 0.5 то зеленый будет отражатся 50%

```
Пусть для источников света: LR, LG, LB
    а для источников материала: MR, MG, MB
Тогда (LR * MR, LG * MG, LB * MB)

Пусть для источника 1: LR1, LG1, LB1
Пусть для источника 2: LR2, LG2, LB2
(LR1 + LR2, LG1 + LG2, LB1 + LB2)
```

#### 5. Алгоритм добавления света в сцену

1. **Определение нормалей для каждой вершины каждого объекта**


```
glNormal<размерность><тип[опционально векторная форма]>(...);
```
Устанавливает текущий вектор нормали согласно аргументам.

##### Пример

```
glBegin(GL_POLYGON);
    glNormal3fv(h0);
    glNormal3fv(v0);
    glNormal3fv(h1);
    glNormal3fv(v0);
    ...
glEnd();
```
Перед вычисление освещенности все вектора автоматически нормальзуются (т.е. приводятся к единичному вектору).
Если используется масштабирование, то нормализащую следует проводить вручную.
Как преобразовать вручную:

```
glEnabel(GL_NORMALIZE);

// менее затратная нормализация
glEnabel(GL_RESCALENORMAL); //однородное масштабирование
```

2. **Создание источника света**

Максимальное количество источников света - 8.
Для управления свойствами источника света используются команды glLight*:

```
glLightf(GLenum light, GLenum pname, GLfloat param);
glLightfv(GLenum light, GLenum pname, const GLfloat *param);
```

Параметр light указывает OpenGL для какого источника света задаются параметры. Команда glLightf используется для задания скалярных параметров, а glLightfv используется для задания векторных характеристик источников света.

[Light](http://compgraphics.info/OpenGL/lighting/light_sources.php)

Имя параметра | Значение по умолчанию                         | Краткий комментарий                                                                                              |
--------------|-----------------------------------------------|------------------------------------------------------------------------------------------------------------------|--
GL_AMBIENT    | (0.0, 0.0, 0.0, 1.0)                          | цвет фонового излучения источника света                                                                          |
GL_DIFFUSE    | (1.0, 1.0, 1.0, 1.0) или (0.0, 0.0, 0.0, 1.0) | цвет рассеянного излучения источника света (значение по умолчанию для GL_LIGHT0 - белый, для остальных - черный) |
GL_SPECULAR   | (1.0, 1.0, 1.0, 1.0) или (0.0, 0.0, 0.0, 1.0) | цвет зеркального излучения источника света (значение по умолчанию для GL_LIGHT0 - белый, для остальных - черный) |

##### Пример

```
GLfloat light_ambient[] = {0.0, 0.0, 0.0, 0.1};
GLfloat light_dif[] = {1., 1., 1., 1.};

glLightfv(GL_LIGHT0, GL_AMBIENT, light_ambient);
glLightfv(GL_LIGHT0, GL_DIFFUSE, light_dif);
```

##### Типы источников света:

* точечные (позиционные, направленные (бесконечно удаленные))
* прожектор (поток света ограничен конусом)
* фоновый

```
glLight3fv(GL_LIGHT0, GL_SPOT_CUTOFF, alpha);
glLight3fv(GL_LIGHT0, GL_SPOT_DIRECTION, ...);
glLight3fv(GL_LIGHT0, GL_CONSTANT_ATTENUATION, ...);
```

3. **Задание модели освещения**

Аспекты:

  1. Интенсивность общего фонового освещения
  2. Пололжение точки обзора
  3. Расчет освещенности для лицевых и обратных граней
  4. Флаг, определяющий необходимость отделения отраженного цвета от других состовляющих (важно при текстурировании)

```
glLightModel{if}[v](GLenum pname, param);
// param - перечисленные аспекты
```

4. **Определение материалов объектов**

```
glMaterial{if}[v](GLenum face, GLenum pname, param);
```

* *face* - может принимать три значения:
    - GL_FRONT
    - GL_BACK
    - GL_FRONT_AND_BACK
* *pname*
    - цвет компонента
    - GL_SHNINESS
    - GL_EMISSION
    - ...
* *param*

##### Пример

```
int main()
{
    ...
    init();
    glDisplayFunc(display);
    ...
    return 0;
}

display()
{
    ...
}

init()
{
        glClearColor(0., 0., 0.);
        glMaterialfv(GL_FRONT, GL_SPECULAR, mat_spec);
        glLightfv(GL_LIGHT0, GL_POSITION, light_pos);
        glLightfv(GL_LIGHT0, GL_DIFFUSE, white_light);
        glLightModel(GL_LIGHT_MODEL, GL_AMBIENT, amb);

        glEnabel(GL_LIGHTING);
        glEnabel(GL_LIGHT0);
        ...
}

```
